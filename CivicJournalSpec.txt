## CivicJournal: Hierarchical Merkle-Chained Delta-Log

### 1. Purpose & Key Differentiators

A **Merkle-Chained Delta-Log** optimized for time-series civic data.

* **Tamper-evident** via hash-chains (no consensus, no tokens).
* **Hierarchical pages** map directly onto real-world time spans (minutes → hours → days → …).
* **Efficient proofs & queries**: leaf-level inclusion, page-level summaries, full history replay.

---

### 2. Core Concepts

| Concept                | Description                                            |
| ---------------------- | ------------------------------------------------------ |
| **Journal Leaf**       | A single “delta” (change) record for a container.      |
| **Hash-Chain**         | Each leaf hashes and links to its predecessor.         |
| **Journal Page**       | Batch of N leaves under one Merkle root.               |
| **Page Chain**         | Pages themselves form a hash-chain of Merkle roots.    |
| **Time Hierarchy**     | Pages grouped into fractal levels (minute→hour→day→…). |
| **External Anchoring** | Periodic timestamping of each page’s root (RFC3161).   |

---

### 3. Time Hierarchy Levels

Pages live in a fractal tree, each level aggregating its children:

| Level | Granularity   | Seconds per Page |
| ----- | ------------- | ---------------- |
| 0     | Minute        | 60               |
| 1     | Hour          | 3,600            |
| 2     | Day           | 86,400           |
| 3     | Month (\~30d) | 2,592,000        |
| 4     | Year (\~365d) | 31,536,000       |
| 5     | Decade        | 315,360,000      |
| 6     | Century       | 3,153,600,000    |

Child pages (“thralls”) roll up into parents at each boundary.

---

### 4. Data Structures

```text
struct JournalLeaf {
  leaf_id: u64,                 // Unique, incrementing ID for the leaf
  timestamp: i64,               // Unix timestamp (seconds) of when the leaf was recorded
  prev_hash: Option<[u8; 32]>,  // Hash of the previous leaf in the same container's logical chain (if any)
  container_id: String,         // Identifier for the data entity this leaf pertains to (e.g., "proposal:XYZ")
  delta_payload: Vec<u8>,       // The actual data/change, as a byte vector (format application-defined)
  leaf_hash: [u8; 32]           // SHA256(leaf_id || timestamp || prev_hash || container_id || delta_payload)
}

struct JournalPage {
  page_id: String,              // Unique identifier for the page (e.g., a UUID or derived from level and start_time)
  level: u8,                    // Time-hierarchy level (0-6)
  start_time: i64,              // Unix timestamp for the start of the page's time window
  end_time: i64,                // Unix timestamp for the end of the page's time window
  // Content depends on the page's role:
  // - Level 0 pages typically contain JournalLeaf objects.
  // - Higher-level pages (L1+) typically contain hashes of their child pages (ThrallHashes).
  content: PageContent,         // Enum: Leaves(Vec<JournalLeaf>) or ThrallHashes(Vec<[u8; 32]>)
  merkle_root: [u8; 32],        // Root of Merkle tree over the page's content
  prev_page_hash: Option<[u8; 32]>, // Hash of the previous JournalPage at the same level (if any)
  page_hash: [u8; 32],          // SHA256 hash of key page fields (e.g., page_id, level, start_time, end_time, merkle_root, prev_page_hash)
  ts_proof: Option<Vec<u8>>     // External timestamp proof for MerkleRoot (e.g., RFC3161, optional)
}

// Note: PageContent is an enum in the implementation:
// enum PageContent {
//   Leaves(Vec<JournalLeaf>),
//   ThrallHashes(Vec<[u8; 32]>), // Hashes of finalized child pages
// }
```

---

### 5. Append & Flush Workflow

1. **Append Leaf**

   * Identify level-0 page by timestamp (minute slot).
   * Compute `PrevHash`, then `LeafHash`.
   * Persist leaf, buffer its hash in that page.

2. **Flush Page** (on N leaves or after T seconds)

   * Build Merkle tree over buffered `LeafHashes` → `MerkleRoot`.
   * Compute `PageHash` (including level and time window).
   * Anchor `MerkleRoot` via TSA/OpenTimestamps → `TSProof`.
   * Persist `JournalPage`, clear buffer, propagate `PageHash` to parent’s buffer as a “thrall” hash.

3. **Roll-up to Higher Levels**

   * When all child pages for an hour (level 0 → 1) are flushed, their `PageHash` values become “delta entries” in the level-1 page buffer, and the same flush logic applies.

4. **Special Event-Triggered Rollups**

   * In addition to time/size-based triggers (e.g., `max_items_per_page`, `max_page_age`), rollups can be initiated programmatically by external events.
   * This allows for on-demand finalization and propagation of pages, useful for integrating with external system workflows or specific data arrival patterns.
   * Such events can trigger a flush and rollup cascade even if normal thresholds have not been met, providing flexibility in managing data aggregation.

---

### 6. Verification & Queries

* **Leaf Inclusion**
  Verify a leaf’s `LeafHash` is in page P via its Merkle-proof path.

* **Page-Chain Integrity**
  Recompute each `PageHash` back to the oldest page at each level.

* **Hierarchy Proof**
  From any level-L page, prove consistency with level (L+1) parent by including the child page’s `PageHash` in the parent’s Merkle tree.

* **State Replay**
  Apply `DeltaPayload`s sequentially from a chosen starting leaf or page to reconstruct container state over time.

* **Query Modes**

  * Time-range: fetch leaves/pages by timestamp.
  * Level-based: retrieve summaries (Merkle roots) without all raw deltas.
  * Container-centric: filter leaves by `ContainerID`.
  * Leaf Inclusion Proofs: Verify that a specific `JournalLeaf` (identified by its `LeafHash`) is part of a `JournalPage`.
    - Current Implementation (`QueryEngine::get_leaf_inclusion_proof`):
      1. Identifies candidate level 0 `JournalPage`s, starting with the active page from `TimeHierarchyManager`.
      2. Loads the `JournalPage` and extracts its `LeafHash` entries.
      3. Dynamically constructs an in-memory `MerkleTree` from these hashes.
      4. Generates a `MerkleProof` for the target leaf within this tree.
      5. **Limitation**: The proof currently returns a **placeholder `JournalLeaf`** (correct `leaf_hash`, dummy data for other fields). Full `JournalLeaf` retrieval by hash is a TODO.
      6. **Scope**: Primarily targets level 0 pages. Search will be extended to archived pages.

---

### 7. Why It’s Not a “Blockchain”

| Blockchain Feature         | CivicJournal Behavior                |
| -------------------------- | ------------------------------------ |
| Fixed blocks & headers     | Flexible pages with start/end fields |
| P2P consensus & tokens     | Single authority + no tokens         |
| On-chain state & contracts | Off-chain DB state + no smart logic  |
| Mining/incentives          | None—pure cryptographic chaining     |

No blocks, no forks, no nodes: **just an auditable, hierarchical Merkle log**.

---

### 8. Storage & Formats

* **Files:** Each `JournalPage` is stored as a single binary file with a `.cjt` extension (e.g., `page_<PageID>.cjt`).
  * The file starts with a 6-byte custom header:
    - Bytes 0-3: Magic string `CJTP` (CivicJournal Time Page).
    - Byte 4: Format Version (e.g., `1`).
    - Byte 5: Compression Algorithm ID (e.g., `0` for None, `1` for Zstd, `2` for Lz4, `3` for Snappy).
  * The rest of the file contains the serialized `JournalPage` data, potentially compressed based on configuration.
* **Dirs:** Pages are organized by level: `/journal/level_<L>/page_<PageID>.cjt` (relative to the storage base path).
* **Marker:** A `.civicjournal-time` marker file may exist at the storage base path to identify it.

---

### 9. References

* **RFC 6962** – Certificate Transparency
* **OpenTimestamps** – decentralized timestamping
* **Google CT whitepaper** – Merkle-based transparency logs
