## CivicJournal: Hierarchical Merkle-Chained Delta-Log

### 1. Purpose & Key Differentiators

A **Merkle-Chained Delta-Log** optimized for time-series civic data.

* **Tamper-evident** via hash-chains (no consensus, no tokens).
* **Hierarchical pages** map directly onto real-world time spans (minutes → hours → days → …).
* **Efficient proofs & queries**: leaf-level inclusion, page-level summaries, full history replay.

---

### 2. Core Concepts

| Concept                | Description                                            |
| ---------------------- | ------------------------------------------------------ |
| **Journal Leaf**       | A single “delta” (change) record for a container.      |
| **Hash-Chain**         | Each leaf hashes and links to its predecessor.         |
| **Journal Page**       | Batch of N leaves under one Merkle root.               |
| **Page Chain**         | Pages themselves form a hash-chain of Merkle roots.    |
| **Time Hierarchy**     | Pages grouped into fractal levels (minute→hour→day→…). |
| **External Anchoring** | Periodic timestamping of each page’s root (RFC3161).   |

---

### 3. Time Hierarchy Levels

Pages live in a fractal tree, each level aggregating its children:

| Level | Granularity   | Seconds per Page |
| ----- | ------------- | ---------------- |
| 0     | Minute        | 60               |
| 1     | Hour          | 3,600            |
| 2     | Day           | 86,400           |
| 3     | Month (\~30d) | 2,592,000        |
| 4     | Year (\~365d) | 31,536,000       |
| 5     | Decade        | 315,360,000      |
| 6     | Century       | 3,153,600,000    |

Child pages (“thralls”) roll up into parents at each boundary.

---

### 4. Data Structures

```text
struct JournalLeaf {
  LeafID        // unique, incrementing
  Timestamp     // e.g. 2025-06-01T12:00:00Z
  PrevHash      // SHA256 of previous LeafHash
  ContainerID   // “proposal:XYZ” or “user:ABC”
  DeltaPayload  // JSON/YAML patch or full record
  LeafHash      // SHA256(LeafID ∥ Timestamp ∥ PrevHash ∥ ContainerID ∥ DeltaPayload)
}

struct JournalPage {
  PageID             // e.g. 42
  Level              // time‐hierarchy level (0…6)
  StartTime, EndTime // page time window
  // Content depends on the page's role:
  // - Level 0 pages typically contain JournalLeaf objects.
  // - Higher-level pages (L1+) typically contain hashes of their child pages (ThrallHashes).
  PageContent        // Enum: Leaves(Vec<JournalLeaf>) or ThrallHashes(Vec<[u8; 32]>)
  MerkleRoot         // root of Merkle-tree over PageContent
  PrevPageHash       // SHA256 of prior JournalPage.PageHash at the same level
  PageHash           // SHA256(PageID ∥ Level ∥ StartTime ∥ EndTime ∥ MerkleRoot ∥ PrevPageHash)
  TSProof            // external timestamp proof for MerkleRoot (optional)
}

// Note: PageContent is an enum in the implementation:
// enum PageContent {
//   Leaves(Vec<JournalLeaf>),
//   ThrallHashes(Vec<[u8; 32]>), // Hashes of finalized child pages
// }
```

---

### 5. Append & Flush Workflow

1. **Append Leaf**

   * Identify level-0 page by timestamp (minute slot).
   * Compute `PrevHash`, then `LeafHash`.
   * Persist leaf, buffer its hash in that page.

2. **Flush Page** (on N leaves or after T seconds)

   * Build Merkle tree over buffered `LeafHashes` → `MerkleRoot`.
   * Compute `PageHash` (including level and time window).
   * Anchor `MerkleRoot` via TSA/OpenTimestamps → `TSProof`.
   * Persist `JournalPage`, clear buffer, propagate `PageHash` to parent’s buffer as a “thrall” hash.

3. **Roll-up to Higher Levels**

   * When all child pages for an hour (level 0 → 1) are flushed, their `PageHash` values become “delta entries” in the level-1 page buffer, and the same flush logic applies.

---

### 6. Verification & Queries

* **Leaf Inclusion**
  Verify a leaf’s `LeafHash` is in page P via its Merkle-proof path.

* **Page-Chain Integrity**
  Recompute each `PageHash` back to the oldest page at each level.

* **Hierarchy Proof**
  From any level-L page, prove consistency with level (L+1) parent by including the child page’s `PageHash` in the parent’s Merkle tree.

* **State Replay**
  Apply `DeltaPayload`s sequentially from a chosen starting leaf or page to reconstruct container state over time.

* **Query Modes**

  * Time-range: fetch leaves/pages by timestamp.
  * Level-based: retrieve summaries (Merkle roots) without all raw deltas.
  * Container-centric: filter leaves by `ContainerID`.
  * Leaf Inclusion Proofs: Verify that a specific `JournalLeaf` (identified by its `LeafHash`) is part of a `JournalPage`.
    - Current Implementation (`QueryEngine::get_leaf_inclusion_proof`):
      1. Identifies candidate level 0 `JournalPage`s, starting with the active page from `TimeHierarchyManager`.
      2. Loads the `JournalPage` and extracts its `LeafHash` entries.
      3. Dynamically constructs an in-memory `MerkleTree` from these hashes.
      4. Generates a `MerkleProof` for the target leaf within this tree.
      5. **Limitation**: The proof currently returns a **placeholder `JournalLeaf`** (correct `leaf_hash`, dummy data for other fields). Full `JournalLeaf` retrieval by hash is a TODO.
      6. **Scope**: Primarily targets level 0 pages. Search will be extended to archived pages.

---

### 7. Why It’s Not a “Blockchain”

| Blockchain Feature         | CivicJournal Behavior                |
| -------------------------- | ------------------------------------ |
| Fixed blocks & headers     | Flexible pages with start/end fields |
| P2P consensus & tokens     | Single authority + no tokens         |
| On-chain state & contracts | Off-chain DB state + no smart logic  |
| Mining/incentives          | None—pure cryptographic chaining     |

No blocks, no forks, no nodes: **just an auditable, hierarchical Merkle log**.

---

### 8. Storage & Formats

* **Files:** Each `JournalPage` is stored as a single binary file with a `.cjt` extension (e.g., `page_<PageID>.cjt`).
  * The file starts with a custom header: 4-byte magic string (`CJTP`) and a 1-byte format version.
  * The rest of the file contains the serialized `JournalPage` data, potentially compressed based on configuration.
* **Dirs:** Pages are organized by level: `/journal/level_<L>/page_<PageID>.cjt` (relative to the storage base path).
* **Marker:** A `.civicjournal-time` marker file may exist at the storage base path to identify it.

---

### 9. References

* **RFC 6962** – Certificate Transparency
* **OpenTimestamps** – decentralized timestamping
* **Google CT whitepaper** – Merkle-based transparency logs
