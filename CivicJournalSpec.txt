## CivicJournal: Hierarchical Merkle-Chained Delta-Log

### 1. Purpose & Key Differentiators

A **Merkle-Chained Delta-Log** optimized for time-series civic data.

* **Tamper-evident** via hash-chains (no consensus, no tokens).
* **Hierarchical pages** map directly onto real-world time spans (minutes → hours → days → …).
* **Efficient proofs & queries**: leaf-level inclusion, page-level summaries, full history replay.

---

### 2. Core Concepts

| Concept                | Description                                            |
| ---------------------- | ------------------------------------------------------ |
| **Journal Leaf**       | A single “delta” (change) record for a container.      |
| **Hash-Chain**         | Each leaf hashes and links to its predecessor.         |
| **Journal Page**       | Batch of N leaves under one Merkle root.               |
| **Page Chain**         | Pages themselves form a hash-chain of Merkle roots.    |
| **Time Hierarchy**     | Pages grouped into fractal levels (minute→hour→day→…). |
| **External Anchoring** | Periodic timestamping of each page’s root (RFC3161).   |

---

### 3. Time Hierarchy Levels

Pages live in a fractal tree, each level aggregating its children:

| Level | Granularity   | Seconds per Page |
| ----- | ------------- | ---------------- |
| 0     | Minute        | 60               |
| 1     | Hour          | 3,600            |
| 2     | Day           | 86,400           |
| 3     | Month (\~30d) | 2,592,000        |
| 4     | Year (\~365d) | 31,536,000       |
| 5     | Decade        | 315,360,000      |
| 6     | Century       | 3,153,600,000    |

Child pages (“thralls”) roll up into parents at each boundary.

---

### 4. File Format (.cjt)

Journal pages are stored in a custom binary format with the following structure:

```
+----------------+----------------+----------------+----------------+----------------+----------------+
| Magic (4B)     | Version (1B)   | Compression (1B) | Page Data (variable)       |
| 'CJTP'         | 0x01           | 0x00-0x03      | (Compressed if applicable)  |
+----------------+----------------+----------------+----------------+-----------+
```

- **Magic (4 bytes)**: `'CJTP'` (0x434A5450) - Identifies the file as a CivicJournal Time Page
- **Version (1 byte)**: `0x01` - Format version
- **Compression (1 byte)**: 
  - `0x00`: None
  - `0x01`: Zstd
  - `0x02`: Lz4
  - `0x03`: Snappy
- **Page Data**: Serialized `JournalPage` structure, optionally compressed

### 5. Data Structures

```text
struct JournalLeaf {
  leaf_id: u64,                 // Unique, incrementing ID for the leaf
  timestamp: i64,               // Unix timestamp (seconds) of when the leaf was recorded
  prev_hash: Option<[u8; 32]>,  // Hash of the previous leaf in the same container's logical chain (if any)
  container_id: String,         // Serves as ObjectID for NetPatches rollup
  delta_payload: serde_json::Value, // The actual delta data, expected to be a JSON object for NetPatch transformation
  leaf_hash: [u8; 32]           // SHA256(leaf_id || timestamp || prev_hash || container_id || delta_payload)
}

enum PageContent {
  Leaves(Vec<JournalLeaf>),     // Level 0: Contains actual journal entries
  ThrallHashes(Vec<[u8; 32]>)  // Level 1+: Contains hashes of child pages
}

struct JournalPage {
  level: u8,                    // Hierarchy level (0 = leaves, 1 = hours, etc.)
  page_id: u64,                 // Unique ID for this page within its level
  creation_timestamp: i64,       // Start of this page's time window
  window_end: i64,               // End of this page's time window
  content: PageContent,          // The actual content (leaves or thrall hashes)
  merkle_root: [u8; 32],        // Root hash of the Merkle tree for this page's content
  first_child_timestamp: i64,   // Timestamp of the first child item
  last_child_timestamp: i64,    // Timestamp of the last child item
  prev_page_hash: Option<[u8; 32]>, // Hash of the previous page at this level
  page_hash: [u8; 32],          // SHA256 hash of key page fields (e.g., page_id, level, start_time, end_time, merkle_root, prev_page_hash)
  ts_proof: Option<Vec<u8>>     // External timestamp proof for MerkleRoot (e.g., RFC3161, optional)
}
//   Leaves(Vec<JournalLeaf>),
//   ThrallHashes(Vec<[u8; 32]>), // Hashes of finalized child pages
// }
```

---

### 5. Append & Flush Workflow

1. **Append Leaf**

   * Identify level-0 page by timestamp (minute slot).
   * Compute `PrevHash`, then `LeafHash`.
   * Persist leaf, buffer its hash in that page.

2. **Flush Page** (on N leaves or after T seconds)

   * Build Merkle tree over buffered `LeafHashes` → `MerkleRoot`.
   * Compute `PageHash` (including level and time window).
   * Anchor `MerkleRoot` via TSA/OpenTimestamps → `TSProof`.
   * Persist `JournalPage`, clear buffer, propagate `PageHash` to parent’s buffer as a “thrall” hash.

3. **Roll-up to Higher Levels**

   * When all child pages for an hour (level 0 → 1) are flushed, their `PageHash` values become “delta entries” in the level-1 page buffer, and the same flush logic applies.

4. **Special Event-Triggered Rollups**

   * In addition to time/size-based triggers (e.g., `max_items_per_page`, `max_page_age`), rollups can be initiated programmatically by external events.
   * This allows for on-demand finalization and propagation of pages, useful for integrating with external system workflows or specific data arrival patterns.
   * Such events can trigger a flush and rollup cascade even if normal thresholds have not been met, providing flexibility in managing data aggregation.

---

### 6. Verification & Queries

* **Leaf Inclusion**
  Verify a leaf’s `LeafHash` is in page P via its Merkle-proof path.

* **Page-Chain Integrity**
  Recompute each `PageHash` back to the oldest page at each level.

* **Hierarchy Proof**
  From any level-L page, prove consistency with level (L+1) parent by including the child page’s `PageHash` in the parent’s Merkle tree.

* **State Replay**
  Apply `DeltaPayload`s sequentially from a chosen starting leaf or page to reconstruct container state over time.

* **Query Modes**

  * Time-range: fetch leaves/pages by timestamp.
  * Level-based: retrieve summaries (Merkle roots) without all raw deltas.
  * Container-centric: filter leaves by `ContainerID`.
  * Leaf Inclusion Proofs: Verify that a specific `JournalLeaf` (identified by its `LeafHash`) is part of a `JournalPage`.
    - Current Implementation (`QueryEngine::get_leaf_inclusion_proof`):
      1. Identifies candidate level 0 `JournalPage`s, starting with the active page from `TimeHierarchyManager`.
      2. Loads the `JournalPage` and extracts its `LeafHash` entries.
      3. Dynamically constructs an in-memory `MerkleTree` from these hashes.
      4. Generates a `MerkleProof` for the target leaf within this tree.
      5. Retrieves the full `JournalLeaf` via `StorageBackend::load_leaf_by_hash` and returns it with the proof.
      6. **Scope**: Primarily targets level 0 pages. Search will be extended to archived pages.

---

### 7. Why It’s Not a “Blockchain”

| Blockchain Feature         | CivicJournal Behavior                |
| -------------------------- | ------------------------------------ |
| Fixed blocks & headers     | Flexible pages with start/end fields |
| P2P consensus & tokens     | Single authority + no tokens         |
| On-chain state & contracts | Off-chain DB state + no smart logic  |
| Mining/incentives          | None—pure cryptographic chaining     |

No blocks, no forks, no nodes: **just an auditable, hierarchical Merkle log**.

---

### 8. Storage & Formats

* **Files:** Each `JournalPage` is stored as a single binary file with a `.cjt` extension (e.g., `page_<PageID>.cjt`).
  * The file starts with a 6-byte custom header:
    - Bytes 0-3: Magic string `CJTP` (CivicJournal Time Page).
    - Byte 4: Format Version (e.g., `1`).
    - Byte 5: Compression Algorithm ID (e.g., `0` for None, `1` for Zstd, `2` for Lz4, `3` for Snappy).
  * The rest of the file contains the serialized `JournalPage` data, potentially compressed based on configuration.
* **Dirs:** Pages are organized by level: `/journal/level_<L>/page_<PageID>.cjt` (relative to the storage base path).
* **Marker:** A `.civicjournal-time` marker file may exist at the storage base path to identify it.

---

### 9. References

* **RFC 6962** – Certificate Transparency
* **OpenTimestamps** – decentralized timestamping
* **Google CT whitepaper** – Merkle-based transparency logs
